require 'matrix'	# IDENTIFIER STRING 
 
class Vector	# KEYWORD_CLASS CONST 
  public :[]=	# IDENTIFIER COLON LSQB RSQB EQUAL 
end	# KEYWORD_end 
 
class Simplex	# KEYWORD_CLASS CONST 
  DEFAULT_MAX_PIVOTS = 10000	# CONST EQUAL INT 
 
  class UnboundedProblem < StandardError	# KEYWORD_CLASS CONST LT CONST 
  end	# KEYWORD_end 
 
  attr_accessor :max_pivots	# IDENTIFIER COLON IDENTIFIER 
 
  def initialize(c, a, b)	# KEYWORD_DEF IDENTIFIER LPAREN IDENTIFIER COMMA IDENTIFIER COMMA IDENTIFIER RPAREN 
    @pivot_count = 0	# IDENTIFIER EQUAL INT 
    @max_pivots = DEFAULT_MAX_PIVOTS	# IDENTIFIER EQUAL CONST 
 
    # Problem dimensions 
    @num_non_slack_vars = a.first.length	# IDENTIFIER EQUAL IDENTIFIER DOT IDENTIFIER DOT IDENTIFIER 
    @num_constraints    = b.length	# IDENTIFIER EQUAL IDENTIFIER DOT IDENTIFIER 
    @num_vars           = @num_non_slack_vars + @num_constraints	# IDENTIFIER EQUAL IDENTIFIER PLUS IDENTIFIER 
 
    # Set up initial matrix A and vectors b, c 
    @c = Vector[*c.map {|c1| -1*c1 } + [0]*@num_constraints]	# IDENTIFIER EQUAL CONST LSQB STAR IDENTIFIER DOT IDENTIFIER LBRACE VERBAR IDENTIFIER VERBAR MINUS INT STAR IDENTIFIER RBRACE PLUS LSQB INT RSQB STAR IDENTIFIER RSQB 
    @a = a.map {|a1| Vector[*(a1.clone + [0]*@num_constraints)]}	# IDENTIFIER EQUAL IDENTIFIER DOT IDENTIFIER LBRACE VERBAR IDENTIFIER VERBAR CONST LSQB STAR LPAREN IDENTIFIER DOT IDENTIFIER PLUS LSQB INT RSQB STAR IDENTIFIER RPAREN RSQB RBRACE 
    @b = Vector[*b.clone]	# IDENTIFIER EQUAL CONST LSQB STAR IDENTIFIER DOT IDENTIFIER RSQB 
 
    unless @a.all? {|a| a.size == @c.size } and @b.size == @a.length	# KEYWORD_UNLESS IDENTIFIER DOT IDENTIFIER TER LBRACE VERBAR IDENTIFIER VERBAR IDENTIFIER DOT IDENTIFIER EQEQUAL IDENTIFIER DOT IDENTIFIER RBRACE KEYWORD_AND IDENTIFIER DOT IDENTIFIER EQEQUAL IDENTIFIER DOT IDENTIFIER 
      raise ArgumentError, "Input arrays have mismatched dimensions" 	# IDENTIFIER CONST COMMA STRING 
    end	# KEYWORD_end 
 
    0.upto(@num_constraints - 1) {|i| @a[i][@num_non_slack_vars + i] = 1 }	# INT DOT IDENTIFIER LPAREN IDENTIFIER MINUS INT RPAREN LBRACE VERBAR IDENTIFIER VERBAR IDENTIFIER LSQB IDENTIFIER RSQB LSQB IDENTIFIER PLUS IDENTIFIER RSQB EQUAL INT RBRACE 
 
    # set initial solution: all non-slack variables = 0 
    @x          = Vector[*([0]*@num_vars)]	# IDENTIFIER EQUAL CONST LSQB STAR LPAREN LSQB INT RSQB STAR IDENTIFIER RPAREN RSQB 
    @basic_vars = (@num_non_slack_vars...@num_vars).to_a	# IDENTIFIER EQUAL LPAREN IDENTIFIER SEQEX IDENTIFIER RPAREN DOT IDENTIFIER 
    update_solution	# IDENTIFIER 
  end	# KEYWORD_end 
 
  def solution	# KEYWORD_DEF IDENTIFIER 
    solve	# IDENTIFIER 
    current_solution	# IDENTIFIER 
  end	# KEYWORD_end 
 
  def current_solution	# KEYWORD_DEF IDENTIFIER 
    @x.to_a[0...@num_non_slack_vars]	# IDENTIFIER DOT IDENTIFIER LSQB INT SEQEX IDENTIFIER RSQB 
  end	# KEYWORD_end 
 
  def update_solution	# KEYWORD_DEF IDENTIFIER 
    0.upto(@num_vars - 1) {|i| @x[i] = 0 }	# INT DOT IDENTIFIER LPAREN IDENTIFIER MINUS INT RPAREN LBRACE VERBAR IDENTIFIER VERBAR IDENTIFIER LSQB IDENTIFIER RSQB EQUAL INT RBRACE 
 
    @basic_vars.each do |basic_var|	# IDENTIFIER DOT IDENTIFIER KEYWORD_DO VERBAR IDENTIFIER VERBAR 
      row_with_1 = row_indices.detect do |row_ix|	# IDENTIFIER EQUAL IDENTIFIER DOT IDENTIFIER KEYWORD_DO VERBAR IDENTIFIER VERBAR 
        @a[row_ix][basic_var] == 1	# IDENTIFIER LSQB IDENTIFIER RSQB LSQB IDENTIFIER RSQB EQEQUAL INT 
      end	# KEYWORD_end 
      @x[basic_var] = @b[row_with_1]	# IDENTIFIER LSQB IDENTIFIER RSQB EQUAL IDENTIFIER LSQB IDENTIFIER RSQB 
    end	# KEYWORD_end 
  end	# KEYWORD_end 
 
  def solve	# KEYWORD_DEF IDENTIFIER 
    while can_improve?	# KEYWORD_WHILE IDENTIFIER TER 
      @pivot_count += 1	# IDENTIFIER PLUSEQ INT 
      raise "Too many pivots" if @pivot_count > max_pivots 	# IDENTIFIER STRING KEYWORD_IF IDENTIFIER GT IDENTIFIER 
      pivot	# IDENTIFIER 
    end	# KEYWORD_end 
  end	# KEYWORD_end 
 
  def can_improve?	# KEYWORD_DEF IDENTIFIER TER 
    !!entering_variable	# NOT NOT IDENTIFIER 
  end	# KEYWORD_end 
 
  def variables	# KEYWORD_DEF IDENTIFIER 
    (0...@c.size).to_a	# LPAREN INT SEQEX IDENTIFIER DOT IDENTIFIER RPAREN DOT IDENTIFIER 
  end	# KEYWORD_end 
 
  def entering_variable	# KEYWORD_DEF IDENTIFIER 
    variables.select { |var| @c[var] < 0 }.	# IDENTIFIER DOT IDENTIFIER LBRACE VERBAR IDENTIFIER VERBAR IDENTIFIER LSQB IDENTIFIER RSQB LT INT RBRACE DOT 
              min_by { |var| @c[var] }	# IDENTIFIER LBRACE VERBAR IDENTIFIER VERBAR IDENTIFIER LSQB IDENTIFIER RSQB RBRACE 
  end	# KEYWORD_end 
 
  def pivot	# KEYWORD_DEF IDENTIFIER 
    pivot_column = entering_variable	# IDENTIFIER EQUAL IDENTIFIER 
    pivot_row    = pivot_row(pivot_column)	# IDENTIFIER EQUAL IDENTIFIER LPAREN IDENTIFIER RPAREN 
    raise UnboundedProblem unless pivot_row	# IDENTIFIER CONST KEYWORD_UNLESS IDENTIFIER 
    leaving_var  = basic_variable_in_row(pivot_row)	# IDENTIFIER EQUAL IDENTIFIER LPAREN IDENTIFIER RPAREN 
    replace_basic_variable(leaving_var => pivot_column)	# IDENTIFIER LPAREN IDENTIFIER EQUAL GT IDENTIFIER RPAREN 
 
    pivot_ratio = Rational(1, @a[pivot_row][pivot_column])	# IDENTIFIER EQUAL CONST LPAREN INT COMMA IDENTIFIER LSQB IDENTIFIER RSQB LSQB IDENTIFIER RSQB RPAREN 
 
    # update pivot row 
    @a[pivot_row] *= pivot_ratio	# IDENTIFIER LSQB IDENTIFIER RSQB STAREQ IDENTIFIER 
    @b[pivot_row] = pivot_ratio * @b[pivot_row]	# IDENTIFIER LSQB IDENTIFIER RSQB EQUAL IDENTIFIER STAR IDENTIFIER LSQB IDENTIFIER RSQB 
 
    # update objective 
    @c -= @c[pivot_column] * @a[pivot_row]	# IDENTIFIER MINUSEQ IDENTIFIER LSQB IDENTIFIER RSQB STAR IDENTIFIER LSQB IDENTIFIER RSQB 
 
    # update A and B 
    (row_indices - [pivot_row]).each do |row_ix|	# LPAREN IDENTIFIER MINUS LSQB IDENTIFIER RSQB RPAREN DOT IDENTIFIER KEYWORD_DO VERBAR IDENTIFIER VERBAR 
      r = @a[row_ix][pivot_column]	# IDENTIFIER EQUAL IDENTIFIER LSQB IDENTIFIER RSQB LSQB IDENTIFIER RSQB 
      @a[row_ix] -= r * @a[pivot_row]	# IDENTIFIER LSQB IDENTIFIER RSQB MINUSEQ IDENTIFIER STAR IDENTIFIER LSQB IDENTIFIER RSQB 
      @b[row_ix] -= r * @b[pivot_row]	# IDENTIFIER LSQB IDENTIFIER RSQB MINUSEQ IDENTIFIER STAR IDENTIFIER LSQB IDENTIFIER RSQB 
    end	# KEYWORD_end 
 
    update_solution	# IDENTIFIER 
  end	# KEYWORD_end 
 
  def replace_basic_variable(hash)	# KEYWORD_DEF IDENTIFIER LPAREN IDENTIFIER RPAREN 
    from, to = hash.keys.first, hash.values.first	# IDENTIFIER COMMA IDENTIFIER EQUAL IDENTIFIER DOT IDENTIFIER DOT IDENTIFIER COMMA IDENTIFIER DOT IDENTIFIER DOT IDENTIFIER 
    @basic_vars.delete(from)	# IDENTIFIER DOT IDENTIFIER LPAREN IDENTIFIER RPAREN 
    @basic_vars << to	# IDENTIFIER LSHIFT IDENTIFIER 
    @basic_vars.sort!	# IDENTIFIER DOT IDENTIFIER NOT 
  end	# KEYWORD_end 
 
  def pivot_row(column_ix)	# KEYWORD_DEF IDENTIFIER LPAREN IDENTIFIER RPAREN 
    row_ix_a_and_b = row_indices.map { |row_ix|	# IDENTIFIER EQUAL IDENTIFIER DOT IDENTIFIER LBRACE VERBAR IDENTIFIER VERBAR 
      [row_ix, @a[row_ix][column_ix], @b[row_ix]]	# LSQB IDENTIFIER COMMA IDENTIFIER LSQB IDENTIFIER RSQB LSQB IDENTIFIER RSQB COMMA IDENTIFIER LSQB IDENTIFIER RSQB RSQB 
    }.reject { |_, a, b|	# RBRACE DOT IDENTIFIER LBRACE VERBAR UNDERSCORE COMMA IDENTIFIER COMMA IDENTIFIER VERBAR 
      a == 0	# IDENTIFIER EQEQUAL INT 
    }.reject { |_, a, b|	# RBRACE DOT IDENTIFIER LBRACE VERBAR UNDERSCORE COMMA IDENTIFIER COMMA IDENTIFIER VERBAR 
      (b < 0) ^ (a < 0) # negative sign check	# LPAREN IDENTIFIER LT INT RPAREN BITXOR LPAREN IDENTIFIER LT INT RPAREN 
    }	# RBRACE 
    row_ix, _, _ = *last_min_by(row_ix_a_and_b) { |_, a, b|	# IDENTIFIER COMMA UNDERSCORE COMMA UNDERSCORE EQUAL STAR IDENTIFIER LPAREN IDENTIFIER RPAREN LBRACE VERBAR UNDERSCORE COMMA IDENTIFIER COMMA IDENTIFIER VERBAR 
      Rational(b, a)	# CONST LPAREN IDENTIFIER COMMA IDENTIFIER RPAREN 
    }	# RBRACE 
    row_ix	# IDENTIFIER 
  end	# KEYWORD_end 
 
  def basic_variable_in_row(pivot_row)	# KEYWORD_DEF IDENTIFIER LPAREN IDENTIFIER RPAREN 
    _column_indices.detect do |column_ix|	# IDENTIFIER DOT IDENTIFIER KEYWORD_DO VERBAR IDENTIFIER VERBAR 
      @a[pivot_row][column_ix] == 1 and @basic_vars.include?(column_ix)	# IDENTIFIER LSQB IDENTIFIER RSQB LSQB IDENTIFIER RSQB EQEQUAL INT KEYWORD_AND IDENTIFIER DOT IDENTIFIER TER LPAREN IDENTIFIER RPAREN 
    end	# KEYWORD_end 
  end	# KEYWORD_end 
 
  def row_indices	# KEYWORD_DEF IDENTIFIER 
    (0...@a.length).to_a	# LPAREN INT SEQEX IDENTIFIER DOT IDENTIFIER RPAREN DOT IDENTIFIER 
  end	# KEYWORD_end 
 
  def column_indices	# KEYWORD_DEF IDENTIFIER 
    (0...@a.first.size).to_a	# LPAREN INT SEQEX IDENTIFIER DOT IDENTIFIER DOT IDENTIFIER RPAREN DOT IDENTIFIER 
  end	# KEYWORD_end 
 
  def formatted_tableau	# KEYWORD_DEF IDENTIFIER 
    if can_improve?	# KEYWORD_IF IDENTIFIER TER 
      pivot_column = entering_variable	# IDENTIFIER EQUAL IDENTIFIER 
      pivot_row    = pivot_row(pivot_column)	# IDENTIFIER EQUAL IDENTIFIER LPAREN IDENTIFIER RPAREN 
    else	# KEYWORD_ELSE 
      pivot_row = nil	# IDENTIFIER EQUAL KEYWORD_NIL 
    end	# KEYWORD_end 
    num_cols = @c.size + 1	# IDENTIFIER EQUAL IDENTIFIER DOT IDENTIFIER PLUS INT 
    c = formatted_values(@c.to_a)	# IDENTIFIER EQUAL IDENTIFIER LPAREN IDENTIFIER DOT IDENTIFIER RPAREN 
    b = formatted_values(@b.to_a)	# IDENTIFIER EQUAL IDENTIFIER LPAREN IDENTIFIER DOT IDENTIFIER RPAREN 
    a = @a.to_a.map {|ar| formatted_values(ar.to_a) }	# IDENTIFIER EQUAL IDENTIFIER DOT IDENTIFIER DOT IDENTIFIER LBRACE VERBAR IDENTIFIER VERBAR IDENTIFIER LPAREN IDENTIFIER DOT IDENTIFIER RPAREN RBRACE 
    if pivot_row	# KEYWORD_IF IDENTIFIER 
      a[pivot_row][pivot_column] = "*" + a[pivot_row][pivot_column]	# IDENTIFIER LSQB IDENTIFIER RSQB LSQB IDENTIFIER RSQB EQUAL STRING PLUS IDENTIFIER LSQB IDENTIFIER RSQB LSQB IDENTIFIER RSQB 
    end	# KEYWORD_end 
    max = (c + b + a + ["1234567"]).flatten.map(&:size).max	# IDENTIFIER EQUAL LPAREN IDENTIFIER PLUS IDENTIFIER PLUS IDENTIFIER PLUS LSQB STRING RSQB RPAREN DOT IDENTIFIER DOT IDENTIFIER LPAREN BITAND COLON IDENTIFIER RPAREN DOT IDENTIFIER 
    result = []	# IDENTIFIER EQUAL LSQB RSQB 
    result << c.map {|c| c.rjust(max, " ") }	# IDENTIFIER LSHIFT IDENTIFIER DOT IDENTIFIER LBRACE VERBAR IDENTIFIER VERBAR IDENTIFIER DOT IDENTIFIER LPAREN IDENTIFIER COMMA STRING RPAREN RBRACE 
    a.zip(b) do |arow, brow|	# IDENTIFIER DOT IDENTIFIER LPAREN IDENTIFIER RPAREN KEYWORD_DO VERBAR IDENTIFIER COMMA IDENTIFIER VERBAR 
      result << (arow + [brow]).map {|a| a.rjust(max, " ") }	# IDENTIFIER LSHIFT LPAREN IDENTIFIER PLUS LSQB IDENTIFIER RSQB RPAREN DOT IDENTIFIER LBRACE VERBAR IDENTIFIER VERBAR IDENTIFIER DOT IDENTIFIER LPAREN IDENTIFIER COMMA STRING RPAREN RBRACE 
      result.last.insert(arow.length, "|")	# IDENTIFIER DOT IDENTIFIER DOT IDENTIFIER LPAREN IDENTIFIER DOT IDENTIFIER COMMA STRING RPAREN 
    end	# KEYWORD_end 
    lines = result.map {|b| b.join("  ") }	# IDENTIFIER EQUAL IDENTIFIER DOT IDENTIFIER LBRACE VERBAR IDENTIFIER VERBAR IDENTIFIER DOT IDENTIFIER LPAREN STRING RPAREN RBRACE 
    max_line_length = lines.map(&:length).max	# IDENTIFIER EQUAL IDENTIFIER DOT IDENTIFIER LPAREN BITAND COLON IDENTIFIER RPAREN DOT IDENTIFIER 
    lines.insert(1, "-"*max_line_length)	# IDENTIFIER DOT IDENTIFIER LPAREN INT COMMA STRING STAR IDENTIFIER RPAREN 
    lines.join("\n")	# IDENTIFIER DOT IDENTIFIER LPAREN STRING RPAREN 
  end	# KEYWORD_end 
 
  def formatted_values(array)	# KEYWORD_DEF IDENTIFIER LPAREN IDENTIFIER RPAREN 
    array.map {|c| "%2.3f" % c }	# IDENTIFIER DOT IDENTIFIER LBRACE VERBAR IDENTIFIER VERBAR STRING MOD IDENTIFIER RBRACE 
  end	# KEYWORD_end 
 
  # like Enumerable#min_by except if multiple values are minimum  
  # it returns the last 
  def last_min_by(array)	# KEYWORD_DEF IDENTIFIER LPAREN IDENTIFIER RPAREN 
    best_element, best_value = nil, nil	# IDENTIFIER COMMA IDENTIFIER EQUAL KEYWORD_NIL COMMA KEYWORD_NIL 
    array.each do |element|	# IDENTIFIER DOT IDENTIFIER KEYWORD_DO VERBAR IDENTIFIER VERBAR 
      value = yield element	# IDENTIFIER EQUAL KEYWORD_YIELD IDENTIFIER 
      if !best_element || value <= best_value	# KEYWORD_IF NOT IDENTIFIER OR IDENTIFIER LTEQUAL IDENTIFIER 
        best_element, best_value = element, value	# IDENTIFIER COMMA IDENTIFIER EQUAL IDENTIFIER COMMA IDENTIFIER 
      end	# KEYWORD_end 
    end	# KEYWORD_end 
    best_element	# IDENTIFIER 
  end	# KEYWORD_end 
 
  def assert(boolean)	# KEYWORD_DEF IDENTIFIER LPAREN IDENTIFIER RPAREN 
    raise unless boolean	# IDENTIFIER KEYWORD_UNLESS IDENTIFIER 
  end	# KEYWORD_end 
 
end	# KEYWORD_end
