require_relative './point.rb'	# IDENTIFIER STRING 
require_relative './edge.rb'	# IDENTIFIER STRING 
require 'set'	# IDENTIFIER STRING 
require 'csv'	# IDENTIFIER STRING 
 
 
module Geometry	# KEYWORD_MODULE CONST 
  class ConvexHull	# KEYWORD_CLASS CONST 
    def self.compute points, be_verbose = false	# KEYWORD_DEF KEYWORD_SELF DOT IDENTIFIER IDENTIFIER COMMA IDENTIFIER EQUAL KEYWORD_FALSE 
      start_time = DateTime.now	# IDENTIFIER EQUAL CONST DOT IDENTIFIER 
      all_sorted_points = points.sort {|a,b| a.x <=> b.x}	# IDENTIFIER EQUAL IDENTIFIER DOT IDENTIFIER LBRACE VERBAR IDENTIFIER COMMA IDENTIFIER VERBAR IDENTIFIER DOT IDENTIFIER NOEQ IDENTIFIER DOT IDENTIFIER RBRACE 
      polygon_hull = compute_edge_hull all_sorted_points, be_verbose	# IDENTIFIER EQUAL IDENTIFIER IDENTIFIER COMMA IDENTIFIER 
 
      set = Array.new	# IDENTIFIER EQUAL CONST DOT IDENTIFIER 
      polygon_hull.each do |edge|	# IDENTIFIER DOT IDENTIFIER KEYWORD_DO VERBAR IDENTIFIER VERBAR 
        set.push edge.p1 unless set.include? edge.p1	# IDENTIFIER DOT IDENTIFIER IDENTIFIER DOT IDENTIFIER KEYWORD_UNLESS IDENTIFIER DOT IDENTIFIER TER IDENTIFIER DOT IDENTIFIER 
        set.push edge.p2 unless set.include? edge.p2	# IDENTIFIER DOT IDENTIFIER IDENTIFIER DOT IDENTIFIER KEYWORD_UNLESS IDENTIFIER DOT IDENTIFIER TER IDENTIFIER DOT IDENTIFIER 
      end	# KEYWORD_end 
      end_time = DateTime.now	# IDENTIFIER EQUAL CONST DOT IDENTIFIER 
 
      calc_time(start_time, end_time) if be_verbose	# IDENTIFIER LPAREN IDENTIFIER COMMA IDENTIFIER RPAREN KEYWORD_IF IDENTIFIER 
 
      return set	# KEYWORD_RETURN IDENTIFIER 
    end	# KEYWORD_end 
 
    private	# IDENTIFIER 
    # basic algorithm, 
    # details here: http://www-m9.ma.tum.de/foswiki/pub/WS2009/AlgorithmischeGeometrie/FolienVAlgGeomV2.pdf 
    def self.compute_edge_hull points, be_verbose = false	# KEYWORD_DEF KEYWORD_SELF DOT IDENTIFIER IDENTIFIER COMMA IDENTIFIER EQUAL KEYWORD_FALSE 
      return [ Edge.new(points.first, points.last)] if points.count <= 2	# KEYWORD_RETURN LSQB CONST DOT IDENTIFIER LPAREN IDENTIFIER DOT IDENTIFIER COMMA IDENTIFIER DOT IDENTIFIER RPAREN RSQB KEYWORD_IF IDENTIFIER DOT IDENTIFIER LTEQUAL INT 
      return [	# KEYWORD_RETURN LSQB 
        Edge.new(points.first, points.last),	# CONST DOT IDENTIFIER LPAREN IDENTIFIER DOT IDENTIFIER COMMA IDENTIFIER DOT IDENTIFIER RPAREN COMMA 
        Edge.new(points.first, points[1]),	# CONST DOT IDENTIFIER LPAREN IDENTIFIER DOT IDENTIFIER COMMA IDENTIFIER LSQB INT RSQB RPAREN COMMA 
        Edge.new(points[1], points.last)	# CONST DOT IDENTIFIER LPAREN IDENTIFIER LSQB INT RSQB COMMA IDENTIFIER DOT IDENTIFIER RPAREN 
      ] if points.count == 3	# RSQB KEYWORD_IF IDENTIFIER DOT IDENTIFIER EQEQUAL INT 
      hull = Array.new	# IDENTIFIER EQUAL CONST DOT IDENTIFIER 
 
      points.permutation(2).each do |p_q|	# IDENTIFIER DOT IDENTIFIER LPAREN INT RPAREN DOT IDENTIFIER KEYWORD_DO VERBAR IDENTIFIER VERBAR 
        edge = Edge.new(p_q[0], p_q[1])	# IDENTIFIER EQUAL CONST DOT IDENTIFIER LPAREN IDENTIFIER LSQB INT RSQB COMMA IDENTIFIER LSQB INT RSQB RPAREN 
        lot_passed = true	# IDENTIFIER EQUAL KEYWORD_TRUE 
        points.each do |r|	# IDENTIFIER DOT IDENTIFIER KEYWORD_DO VERBAR IDENTIFIER VERBAR 
          lot_passed = false unless r.left_of? edge.p1, edge.p2	# IDENTIFIER EQUAL KEYWORD_FALSE KEYWORD_UNLESS IDENTIFIER DOT IDENTIFIER TER IDENTIFIER DOT IDENTIFIER COMMA IDENTIFIER DOT IDENTIFIER 
        end	# KEYWORD_end 
        if lot_passed and not hull.include? edge	# KEYWORD_IF IDENTIFIER KEYWORD_AND KEYWORD_NOT IDENTIFIER DOT IDENTIFIER TER IDENTIFIER 
          hull.push(edge)	# IDENTIFIER DOT IDENTIFIER LPAREN IDENTIFIER RPAREN 
          puts "#{edge} is a hull edge" if be_verbose	# IDENTIFIER STRING KEYWORD_IF IDENTIFIER 
        end	# KEYWORD_end 
      end	# KEYWORD_end 
 
      return hull	# KEYWORD_RETURN IDENTIFIER 
    end	# KEYWORD_end 
 
    def self.calc_time start_time, end_time	# KEYWORD_DEF KEYWORD_SELF DOT IDENTIFIER IDENTIFIER COMMA IDENTIFIER 
      start_ms = start_time.strftime("%Q").to_i	# IDENTIFIER EQUAL IDENTIFIER DOT IDENTIFIER LPAREN STRING RPAREN DOT IDENTIFIER 
      end_ms = end_time.strftime("%Q").to_i	# IDENTIFIER EQUAL IDENTIFIER DOT IDENTIFIER LPAREN STRING RPAREN DOT IDENTIFIER 
      duration_ms = end_ms - start_ms	# IDENTIFIER EQUAL IDENTIFIER MINUS IDENTIFIER 
 
      if duration_ms > 2000	# KEYWORD_IF IDENTIFIER GT INT 
        duration = (duration_ms / 1000.to_f).round(3)	# IDENTIFIER EQUAL LPAREN IDENTIFIER DIV INT DOT IDENTIFIER RPAREN DOT IDENTIFIER LPAREN INT RPAREN 
        time_unit = "seconds"	# IDENTIFIER EQUAL STRING 
      else	# KEYWORD_ELSE 
        duration = duration_ms	# IDENTIFIER EQUAL IDENTIFIER 
        time_unit = "microseconds"	# IDENTIFIER EQUAL STRING 
      end	# KEYWORD_end 
 
      puts "Hull Calculation took #{duration} #{time_unit}"	# IDENTIFIER STRING 
    end	# KEYWORD_end 
  end	# KEYWORD_end 
end	# KEYWORD_end
