program : compstmt

#Statements with any number of line terminals
compstmt : stmts opt_terms

#Statements that cannot end with line terminals
stmts : none
	| stmt
	| stmts lin_terms stmt

#Single statement
#Note we use lhs op_assign which may be wrong for semantic
#For semantic, divide into var_lhs and rest
stmt : KEYWORD_END '{' compstmt '}'
	| KEYWORD_BEGIN '{' compstmt '}'	
	| command_assign
	| lhs op_assign command_call
	| expr

#Assignment Command (lhs = lhs = ... = command_call)
command_assign : lhs '=' command_call
	| lhs '=' command_assign

#Expressions (Evaluate to a value)
expr : command_call
	| '!' command_call
	| KEYWORD_NOT expr
	| expr KEYWORD_AND expr
	| expr KEYWORD_OR expr
	| arg

#Method Call without parenthesis
command_call : 

prime : literal 
	| variable 
	| if_expr 
	| unless_expr 
	| case_expr 
	| while_expr 
	| until_expr 
	| for_expr 
	| yield_expr 
	| array_cons 
	| KEYWORD_BREAK 
	| KEYWORD_NEXT 
	| KEYWORD_REDO 
	| class_def 
	| method_def 
	| singleton_class_def 
	| singleton_method_def 
	| KEYWORD_BREAK 
	| KEYWORD_RETRY 
	| KEYWORD_REDO 
	| KEYWORD_NEXT 
	| KEYWORD_RETURN 
	| '(' compstmt ')' 
	| KEYWORD_DEFINED '(' expr ')' 

class_def : 

method_def : KEYWORD_END method_name 


method_name : key_var 
	| LOCALVAR 
	| CONST 


singleton_class_def : KEYWORD_CLASS LSHIFT expr 


if_expr : KEYWORD_IF expr then compstmt if_tail KEYWORD_END

then : lin_ter 
	| KEYWORD_THEN 
	| term KEYWORD_THEN

if_tail : opt_else 
	| KEYWORD_ELSIF expr then compstmt if_tail

opt_else : KEYWORD_ELSE compstmt 
	| none


unless_expr : KEYWORD_UNLESS expr then compstmt opt_else KEYWORD_END


case_expr : KEYWORD_CASE expr opt_terms case_body KEYWORD_END 
	| KEYWORD_CASE opt_terms case_body KEYWORD_END



case_body : KEYWORD_WHEN args then compstmt cases

cases : opt_else 
	| case_body


while_expr : KEYWORD_WHILE expr do compstmt KEYWORD_END

do : lin_ter 
	| KEYWORD_DO


until_expr : KEYWORD_UNTIL expr do compstmt KEYWORD_END


for_expr : KEYWORD_FOR for_var KEYWORD_IN expr do compstmt KEYWORD_END

for_var : lhs 
	| mlhs


yield_expr : KEYWORD_YIELD opt_call_args

opt_call_args : '(' ')' 
	| '(' call_args ')' 
	| none


arg : lhs '=' arg 
	| arg DOT2 arg 
	| arg DOT3 arg 
	| arg '+' arg 
	| arg '-' arg 
	| arg '*' arg 
	| arg '/' arg 
	|arg '%' arg 
	| arg POW arg 
	| '+' arg 
	| '-' arg 
	| arg '
	|' arg 
	| arg '^' arg 
	| arg '&' arg 
	| arg '>' arg 
	| arg '<' arg 
	| '!' arg 
	| '~' arg 
	| arg LEQ arg 
	| arg GEQ arg 
	| arg LSHIFT arg 
	| arg RSHIFT arg 
	| arg AND arg 
	| arg OR arg 
	| arg NOTEQ arg 
	| arg NOEQ arg 
	| arg EQEQ arg 
	| arg CASEEQ arg 
	| KEYWORD_DEFINED arg 
	| prime 
	| arg '?' arg ':' arg




#Pretty self explanatory names

opt_terms : none 
	| lin_terms

lin_terms : lin_term 
	| lin_terms ';'

lin_term : ';' 
	| NEWLINE

opt_nl : none
	| NEWLINE

literal : numeric 
	| CHAR 
	| STRING

op_assign : PLUSEQ
	| MINUSEQ
	| STAREQ
	| DIVEQ
	| MODEQ
	| POWEQ

numeric : INT 
	| FLOAT

user_var : LOCALVAR 
	| GLOBALVAR 
	| CLASSVAR 
	| INSTANCEVAR 
	| METHOD_ASSGN_VAR 
	| METHOD_ONLY_VAR 
	| CONST

key_var : KEYWORD_NIL 
	| KEYWORD_SELF 
	| KEYWORD_FALSE 
	| KEYWORD_TRUE 
	| KEYWORD_FILE 
	| KEYWORD_LINE 
	| KEYWORD_ENCODING

none : 
